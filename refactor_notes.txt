- Map devPtr for IPC with cudaIpcGetMemHandle(cudaIpcMemHandle_t* handle, void* devPtr)

- Use cudaDeviceSynchronize() to wait for an operation to complete (libav probably already does this during decoding? maybe only needed for in toolkit for invoking kernels?)

- Use cudaIpcOpenMemHandle(void** devPtr, cudaIpcMemHandle_t handle, unsigned int flags) to unwrap the ipc handle for a useable devPtr

- Use cudaIpcCloseMemHandle(void* devPtr) to close memory map in consumer process when finished

#include <cuda_runtime.h> to get access to cuda IPC definitions and link -lcudart

Tell CUVID how many frames to allocate per decoder with the "surfaces" dict key

Each thread gets an atomic counter in the shared memory block
- increment the counter before decoding, if counter >= total_frames then enter wait loop
- main thread decrements when cycling frames
- otherwise consumer process iterates over all counters and decrements when finished with frameset

No longer need "filled" and "empty" queues for frame management, only a single queue at each junction

Instead of frame buffers, timestamped frame containers, and frameset slots in shared memory, allocate an array of cudaIpcMemHandle_t's and enqueue pointers (or indices) and fill a subarray of them with frame buffer devPtrs offset by cam_count

May need one more atomic counter to track the number of cudaIpcMemHandle_t subarrays available as well

Grab the devPtr from AVFrame->data[0] and use as you would any other devPtr

Since the frames are 1280x720, pitch == linesize == width, and AVFrame->linesize[0] is for the y plane, and AVFrame->linesize[1] is for the uv plane
